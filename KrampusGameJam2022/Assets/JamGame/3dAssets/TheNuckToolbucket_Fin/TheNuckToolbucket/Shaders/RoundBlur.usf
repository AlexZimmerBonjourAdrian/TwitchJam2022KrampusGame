//INPUTS: Globals (Utility functions), int Range (actually float, half range),
//bool bIsRadial (actually float)

static const int SceneTextureId = 14;
float2 TexelSize = View.ViewSizeAndInvSize.zw;
float2 SceneSize = View.ViewSizeAndInvSize.xy;
float2 UV = GetDefaultSceneTextureUV(Parameters, SceneTextureId);

float2 PolarUV = CartesianToPolar(UV);
float3 Pixel = SceneTextureLookup(UV, SceneTextureId, 0).rgb;
int Samples = 1;

for(int i = 0; i < Range; ++i)
{
	float2 minUV;
	float2 maxUV;
	
	//source: http://chemaguerra.com/circular-radial-blur/
	//the row/column thing is flipped though and in this case
	//radial blur is given by row blur, while circular blur is 
	//given by column blur. Probably has to do with HLSL using 
	//column rather than row matrices - if I'm correct
	if(bIsRadial > 0.0f)
	{
		minUV = float2(-i, 0) * TexelSize;
		maxUV = float2(i, 0) * TexelSize;
		
		/*
		if(-i < 0)
		{
			minUV = float2(0, 0);
		}
		else
		{
			minUV = float2(-i, 0) * TexelSize;
		}
		
		if(i > SceneSize.x)
		{
			maxUV = float2(0,0);
		}
		else
		{
			maxUV = float2(i, 0) * TexelSize;
		}
		*/
	}
	else
	{
		minUV = float2(0, -i) * TexelSize;
		maxUV = float2(0, i) * TexelSize;
	}
	
	Pixel += SceneTextureLookup(PolarToCartesian(PolarUV + minUV), SceneTextureId, 0).rgb;
	Pixel += SceneTextureLookup(PolarToCartesian(PolarUV + maxUV), SceneTextureId, 0).rgb;
	Samples += 2;
}

Pixel /= Samples;
return Pixel;